//////////////////////////////////////////////////////////////////////////////////
//
// Montek Singh
// 3/27/2020
//
//////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps
`default_nettype none


// NOTE: There should not be any need to modify anything below!!!!
// Any changes to parameters must be made in the tester, from which
// actual parameter values are inherited.


module top #(
    parameter Dbits=32,                                     // word size for the processor
    parameter Nreg=32,                                      // number of registers

    parameter imem_size=478,                                // imem size, must be >= # instructions in program
    parameter imem_init="final_imem.mem",                   // use this line for synthesis/board deployment

    //parameter dmem_size=1024,                               // dmem size, must be >= # words in .data of program + size of stack
    parameter dmem_size=1200,                               // dmem size, must be >= # words in .data of program + size of stack
    parameter dmem_init="final_dmem.mem",                   // file to initialize data memory

    parameter smem_size=1200,                               // smem size, is 1200 for our chosen screen grid of 40x30
    parameter smem_init="final_smem.mem", 	                // file to initialize screen memory

    parameter bmem_size=768,                                // bmem size, 256 * # of characters.  For 4 chars, = 1024.
    parameter bmem_init="final_bmem.mem" 	                // file to initialize bitmap memory
)(
    // System clock + reset signal 
    input wire clk, reset,
    
    // vga display 
    output wire [3:0] red, green, blue,
    output wire hsync, vsync,
    
    // keyboard 
    input wire ps2_clk,
    input wire ps2_data,
    
    // acceleration 
    output wire aclSCK,
    output wire aclMOSI,
    input wire aclMISO,
    output wire aclSS,
    
    // Lights
    output wire [15:0] LED,
    
    // Sound 
    output wire audPWM,
    output wire audEn,
    
    // 7 segment 8 bit display  
    output logic [7:0] segments,
    output logic [7:0] digitselect, 
    
    // BUTTONS 
    input wire BTNU, BTNC, BTND
);

    // Available for debugging purposes.
   wire enable = 1'b1;      
   wire smem_reading, dmem_reading; 

   wire [31:0] pc, instr, mem_readdata, mem_writedata, mem_addr;
   wire mem_wr;
   wire clk100, clk50, clk25, clk12;

   wire [10:0] smem_addr;
   wire [3:0] charcode;         // increase #bits if using more than 16 characters
   wire [31:0] keyb_char;
   wire [8:0] accelX, accelY; 
   wire [11:0] accelTmp; 
   wire [31:0] period; 

   // Uncomment *only* one of the following two lines:
   //    when synthesizing, use the first line
   //    when simulating, get rid of the clock divider, and use the second line
   //
   clockdivider_Nexys4 clkdv(clk, clk100, clk50, clk25, clk12);   // use this line for synthesis/board deployment
//   assign clk100=clk; assign clk50=clk; assign clk25=clk; assign clk12=clk;  // use this line for simulation/testing

   // For synthesis:  use an appropriate clock frequency(ies) below
   //   clk100 will work for hardly anyone
   //   clk50 or clk 25 may work for some
   //   clk12 should work for everyone!  So, please use clk12 for your processor and data memory.
   //
   // Important:  Use the same clock frequency for the MIPS and the memIO modules.
   // The I/O devices, however, should keep the 100 MHz clock.
   // For example:

   // CPU 
   mips #(.Dbits(Dbits), .Nreg(Nreg)) mips(
    .clk(clk12), 
    .reset(reset), 
    .enable(enable), 
    .pc(pc), 
    .instr(instr), 
    .mem_wr(mem_wr), 
    .mem_addr(mem_addr), 
    .mem_writedata(mem_writedata), 
    .mem_readdata(mem_readdata)
   );

   // Instruction Memory 
   rom_module #(.Nloc(imem_size), .Dbits(Dbits), .initfile(imem_init)) imem (
    pc[31:2], // dropped two LSBs from address to instr mem to convert byte address to word address
    instr
   ); 

   // Memory Mapping module    
    memIO #(.dmem_init(dmem_init), .smem_init(smem_init)) memIO (
        .clock(clk12), 
        .cpu_wr(mem_wr), 
        .cpu_addr(mem_addr),
        .cpu_writedata(mem_writedata), 
        .cpu_readdata(mem_readdata), 
        .vga_addr(smem_addr), 
        .vga_readdata(charcode), 
        .accelX(accelX),
        .accelY(accelY), 
        .keyb_char(keyb_char), 
        .lights(LED),
        .period(period),
        
        // DEBUGGING 
        .smem_reading(smem_reading), 
        .dmem_reading(dmem_reading)
    ); 
    
   // I/O devices
   //
   // Note: All I/O devices were developed assuming a 100 MHz clock.
   //   Therefore, the clock sent to them must be clk100, not any of the
   //   slower clocks generated by the clock divider.

   vgadisplaydriver #(
        .nrows(30), 
        .ncols(40),
        .nloc(1200),
        .charCount(16),
        .charDim(16),
        .bmem_init(bmem_init)
    ) display (
        .clk(clk100),
        .charCode(charcode),
        .screenAddr(smem_addr),
        .red(red),
        .green(green),
        .blue(blue),
        .hsync(hsync),
        .vsync(vsync)
    );

   // Uncomment the following to instantiate these other I/O devices.
   //   You will have to declare all the wires that connect to them.

//    keyboard keyb(clk100, ps2_clk, ps2_data, keyb_char);

    buttonInput buttonInputDevice (.clk(clk100), .BTNC(BTNC), .BTNU(BTNU), .BTND(BTND), .keyb_char(keyb_char)); 
    display8digit disp(keyb_char, clk100, segments, digitselect);    
    accelerometer accel(clk100, aclSCK, aclMOSI, aclMISO, aclSS, accelX, accelY, accelTmp);
    montek_sound_Nexys4 sound(clk100, period, audPWM);

endmodule